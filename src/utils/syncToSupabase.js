
import { db } from '../db/db';
import { supabase } from '../db/supabase';

export const syncLocalToCloud = async (onProgress) => {
    try {
        if (!supabase) {
            throw new Error('Chưa cấu hình Supabase. Vui lòng tạo file .env và điền thông tin VITE_SUPABASE_URL, VITE_SUPABASE_ANON_KEY.');
        }

        if (onProgress) onProgress('Đang kiểm tra kết nối...', 0);

        const { data, error } = await supabase.from('users').select('count', { count: 'exact', head: true });

        if (error) {
            console.error("Supabase connection error:", error);
            throw new Error('Không thể kết nối đến Cloud Database. Vui lòng kiểm tra file .env hoặc Internet.');
        }

        const tables = [
            { dexie: 'vehicles', supabase: 'vehicles' },
            { dexie: 'logs', supabase: 'logs' },
            { dexie: 'maintenanceLogs', supabase: 'maintenance_logs', map: (row) => ({ ...row, vehicleId: row.vehicleId }) }, // vehicleId ref might need checking if IDs change, but for now assuming direct ID mapping or relying on upsert constraints if we had UUIDs. Dexie uses auto-inc numbers. Supabase schema used BIGINT IDENTITY. IDs should preserve if we insert them explicitly.
            { dexie: 'users', supabase: 'users' },
            { dexie: 'projects', supabase: 'projects' },
            { dexie: 'parts', supabase: 'parts' },
            { dexie: 'errorCodes', supabase: 'error_codes' },
            { dexie: 'maintenanceSupplies', supabase: 'maintenance_supplies' },
            // reportSnapshots and chatHistory might be heavy, skip for now or make optional? Let's include for completeness.
            { dexie: 'reportSnapshots', supabase: 'report_snapshots' },
        ];

        const totalTables = tables.length;

        for (let i = 0; i < totalTables; i++) {
            const table = tables[i];
            if (onProgress) onProgress(`Đang đồng bộ bảng: ${table.supabase}...`, Math.round((i / totalTables) * 100));

            // Get all data from Dexie
            let rows = await db.table(table.dexie).toArray();

            if (rows.length === 0) continue;

            // Prepare data for Supabase
            // We need to clean keys if needed. Dexie might have extra keys not in Supabase, but our schema is close.
            // Importantly: Supabase 'id' is generated by default as identity.
            // If we want to PRESERVE IDs, we should include them.
            // If the user already has data on Cloud, this might conflict if IDs clash.
            // For a "First Sync", we enforce IDs.

            const records = rows.map(row => {
                let r = { ...row };
                if (table.map) {
                    r = table.map(r);
                }

                // Fix Date objects to Strings (Supabase expects ISO strings or Date strings)
                Object.keys(r).forEach(key => {
                    if (r[key] instanceof Date) {
                        r[key] = r[key].toISOString();
                    }
                });

                return r;
            });

            // Upsert in batches to avoid payload limits
            const BATCH_SIZE = 100;
            for (let j = 0; j < records.length; j += BATCH_SIZE) {
                const batch = records.slice(j, j + BATCH_SIZE);
                const { error: upsertError } = await supabase.from(table.supabase).upsert(batch);

                if (upsertError) {
                    console.error(`Error syncing table ${table.supabase}:`, upsertError);
                    // Continue with other tables/batches? Or stop?
                    // Let's log and continue for resilience, but warn user.
                }
            }
        }

        if (onProgress) onProgress('Đồng bộ hoàn tất!', 100);
        return { success: true };

    } catch (err) {
        console.error("Sync failed:", err);
        return { success: false, error: err.message };
    }
};
